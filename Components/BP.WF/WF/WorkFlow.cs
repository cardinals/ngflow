using System;
using BP.En;
using BP.Web;
using BP.DA;
using System.Collections;
using System.Data;
using BP.Port;
using BP.Sys;
using BP.WF.Template;
using BP.WF.Data;

namespace BP.WF
{
    /// <summary>
    /// WF  The summary .
    ///  Workflow 
    ///  This contains two aspects 
    ///  Information Work го
    ///  Process Information го
    /// </summary>
    public class WorkFlow
    {
        #region  Statistics for the current job 
        /// <summary>
        ///  The number of the normal range of operation .
        /// </summary>
        public static int NumOfRuning(string FK_Emp)
        {
            string sql = "SELECT COUNT(*) FROM V_WF_CURRWROKS WHERE FK_Emp='" + FK_Emp + "' AND WorkTimeState=0";
            return DBAccess.RunSQLReturnValInt(sql);
        }
        /// <summary>
        ///  The number of entry warning period 
        /// </summary>
        public static int NumOfAlert(string FK_Emp)
        {
            string sql = "SELECT COUNT(*) FROM V_WF_CURRWROKS WHERE FK_Emp='" + FK_Emp + "' AND WorkTimeState=1";
            return DBAccess.RunSQLReturnValInt(sql);
        }
        /// <summary>
        ///  Overdue 
        /// </summary>
        public static int NumOfTimeout(string FK_Emp)
        {
            string sql = "SELECT COUNT(*) FROM V_WF_CURRWROKS WHERE FK_Emp='" + FK_Emp + "' AND WorkTimeState=2";
            return DBAccess.RunSQLReturnValInt(sql);
        }
        #endregion

        #region   Rights Management 
        /// <summary>
        ///  Is not able to make the current working .
        /// </summary>
        /// <param name="empId"> Staff ID</param>
        /// <returns> Is not able to make the current working </returns>
        public bool IsCanDoCurrentWork(string empId)
        {
            WorkNode wn = this.GetCurrentWorkNode();
            return BP.WF.Dev2Interface.Flow_IsCanDoCurrentWork(wn.HisNode.NodeID, wn.WorkID, empId);
            #region  Use dev2InterFace  The algorithm 
            //return true;
            //  Find current work node 

            //  Judgment is not to work node ..
            if (wn.HisNode.IsStartNode)
            {
                //  Judge is not physically have the privilege .
                // return WorkFlow.IsCanDoWorkCheckByEmpStation(wn.HisNode.NodeID, empId);
                return true;
            }

            //  Judge his work generated by worker .
            GenerWorkerLists gwls = new GenerWorkerLists(this.WorkID, wn.HisNode.NodeID);
            if (gwls.Count == 0)
            {
                //return true;
                //throw new Exception("@ Workflow definition error , Did not find the person is capable of performing this work . Related Information : The work ID="+this.WorkID+", Node ID="+wn.HisNode.NodeID );
                throw new Exception("@ Workflow definition error , Did not find the person is capable of performing this work . Related Information :WorkID=" + this.WorkID + ",NodeID=" + wn.HisNode.NodeID);
            }

            foreach (GenerWorkerList en in gwls)
            {
                if (en.FK_Emp == empId)
                    return true;
            }
            return false;
            #endregion
        }
        #endregion

        #region  Process Public Methods 
        /// <summary>
        ///  Execution rejected 
        ///  Scenarios : When the child process to dismiss the division point 
        /// </summary>
        /// <param name="fid"></param>
        /// <param name="fk_node"> Was dismissed node </param>
        /// <param name="msg"></param>
        /// <returns></returns>
        public string DoReject(Int64 fid, int fk_node, string msg)
        {
            GenerWorkerList wl = new GenerWorkerList();
            int i = wl.Retrieve(GenerWorkerListAttr.FID, fid,
                GenerWorkerListAttr.WorkID, this.WorkID,
                GenerWorkerListAttr.FK_Node, fk_node);
            //if (i == 0)
            //    throw new Exception(" System error , No data found be found .");

            i = wl.Delete();
            //if (i == 0)
            //    throw new Exception(" System error , Do not delete the data should be deleted .");

            wl = new GenerWorkerList();
            i = wl.Retrieve(GenerWorkerListAttr.FID, fid,
                GenerWorkerListAttr.WorkID, this.WorkID,
                GenerWorkerListAttr.IsPass, 3);

            //if (i == 0)
            //    throw new Exception(" System error , Returned to find the original starting point not found .");

            Node nd = new Node(fk_node);
            //  Update setup process management table of the current node in the current .
            DBAccess.RunSQL("UPDATE WF_GenerWorkFlow SET FK_Node=" + fk_node + ", NodeName='" + nd.Name + "' WHERE WorkID=" + this.WorkID);

            wl.RDT = DataType.CurrentDataTime;
            wl.IsPass = false;
            wl.Update();

            return " Work has been rejected to (" + wl.FK_Emp + " , " + wl.FK_EmpText + ")";
            // wl.HisNode
        }
        /// <summary>
        ///  Tombstone Process 
        /// </summary>
        /// <param name="msg"> Tombstone flow reasons , Can be empty .</param>
        public void DoDeleteWorkFlowByFlag(string msg)
        {
            try
            {
                // Set generated workflow .
                GenerWorkFlow gwf = new GenerWorkFlow(this.WorkID);
                gwf.WFState = BP.WF.WFState.Delete;
                gwf.Update();

                // Logging   Thanks  itdos and 888 ,  The proposed bug.
                WorkNode wn = new WorkNode(WorkID, gwf.FK_Node);
                wn.AddToTrack(ActionType.DeleteFlowByFlag, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name,
                        msg);

                string sql = "UPDATE  " + this.HisFlow.PTable + " SET WFState=" + (int)WFState.Delete + " WHERE OID=" + this.WorkID;
                DBAccess.RunSQL(sql);
            }
            catch (Exception ex)
            {
                Log.DefaultLogWriteLine(LogType.Error, "@ Tombstone error :" + ex.Message);
                throw new Exception("@ Tombstone error :" + ex.Message);
            }
        }
        /// <summary>
        ///  Recovery processes tombstone 
        /// </summary>
        /// <param name="msg"> Reply reasons , Can be empty .</param>
        public void DoUnDeleteWorkFlowByFlag(string msg)
        {
            try
            {
                DBAccess.RunSQL("UPDATE WF_GenerWorkFlow SET WFState=" + (int)WFState.Runing + " WHERE  WorkID=" + this.WorkID);

                // Set generated workflow .
                GenerWorkFlow gwf = new GenerWorkFlow(this.WorkID);
                gwf.WFState = BP.WF.WFState.Runing;
                gwf.Update();

                WorkNode wn = new WorkNode(WorkID, gwf.FK_Node);
                wn.AddToTrack(ActionType.UnDeleteFlowByFlag, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name,
                        msg);
            }
            catch (Exception ex)
            {
                Log.DefaultLogWriteLine(LogType.Error, "@ Tombstone error :" + ex.Message);
                throw new Exception("@ Tombstone error :" + ex.Message);
            }
        }
        /// <summary>
        ///  Deletion process has been completed 
        /// </summary>
        /// <param name="flowNo"> Process ID </param>
        /// <param name="workID"> The work ID</param>
        /// <param name="isDelSubFlow"> Do you want to delete the sub-processes </param>
        /// <param name="note"> Reason for deletion </param>
        /// <returns> Removal Information </returns>
        public static string DoDeleteWorkFlowAlreadyComplete(string flowNo, Int64 workID, bool isDelSubFlow, string note)
        {
            Log.DebugWriteInfo(" Start deleting process : Process ID :" + flowNo + "-WorkID:" + workID + "-" + ".  Do you want to delete the sub-processes :" + isDelSubFlow + "; Reason for deletion :" + note);

            Flow fl = new Flow(flowNo);

            #region  Delete the log recording process 
            GERpt rpt = new GERpt("ND" + int.Parse(flowNo) + "Rpt");
            rpt.SetValByKey(GERptAttr.OID, workID);
            rpt.Retrieve();
            WorkFlowDeleteLog log = new WorkFlowDeleteLog();
            log.OID = workID;
            try
            {
                log.Copy(rpt);
                log.DeleteDT = DataType.CurrentDataTime;
                log.OperDept = WebUser.FK_Dept;
                log.OperDeptName = WebUser.FK_DeptName;
                log.Oper = WebUser.No;
                log.DeleteNote = note;
                log.OID = workID;
                log.FK_Flow = flowNo;
                log.FK_FlowSort = fl.FK_FlowSort;
                log.InsertAsOID(log.OID);
            }
            catch (Exception ex)
            {
                log.CheckPhysicsTable();
                log.Delete();
                return ex.StackTrace;
            }
            #endregion  Delete the log recording process 

            DBAccess.RunSQL("DELETE FROM ND" + int.Parse(flowNo) + "Track WHERE WorkID=" + workID);
            DBAccess.RunSQL("DELETE FROM " + fl.PTable + " WHERE OID=" + workID);
            DBAccess.RunSQL("DELETE FROM WF_CHEval WHERE  WorkID=" + workID); //  Delete the data quality assessment .

            string info = "";

            #region  Normal delete information .
            string msg = "";
            try
            {
                //  Delete the document information .
                DBAccess.RunSQL("DELETE FROM WF_CCList WHERE WorkID=" + workID);

                //  Delete the document information .
                DBAccess.RunSQL("DELETE FROM WF_Bill WHERE WorkID=" + workID);
                //  Delete return .
                DBAccess.RunSQL("DELETE FROM WF_ReturnWork WHERE WorkID=" + workID);
                //  Delete transfer .
                // DBAccess.RunSQL("DELETE FROM WF_ForwardWork WHERE WorkID=" + workID);

                // Remove it work .
                DBAccess.RunSQL("DELETE FROM WF_GenerFH WHERE  FID=" + workID);
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow WHERE (WorkID=" + workID + " OR FID=" + workID + " ) AND FK_Flow='" + flowNo + "'");
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkerList WHERE (WorkID=" + workID + " OR FID=" + workID + " ) AND FK_Flow='" + flowNo + "'");

                // Delete all the data on the node .
                Nodes nds = fl.HisNodes;
                foreach (Node nd in nds)
                {
                    try
                    {
                        DBAccess.RunSQL("DELETE FROM ND" + nd.NodeID + " WHERE OID=" + workID + " OR FID=" + workID);
                    }
                    catch (Exception ex)
                    {
                        msg += "@ delete data error " + ex.Message;
                    }
                }
                if (msg != "")
                {
                    Log.DebugWriteInfo(msg);
                }
            }
            catch (Exception ex)
            {
                string err = "@ Delete Workflow  Err " + ex.TargetSite;
                Log.DefaultLogWriteLine(LogType.Error, err);
                throw new Exception(err);
            }
            info = "@ Delete process deleted successfully ";
            #endregion  Normal delete information .

            #region  Delete the following sub-processes of the process .
            if (isDelSubFlow)
            {
                GenerWorkFlows gwfs = new GenerWorkFlows();
                gwfs.Retrieve(GenerWorkFlowAttr.PWorkID, workID);
                foreach (GenerWorkFlow item in gwfs)
                    BP.WF.Dev2Interface.Flow_DoDeleteFlowByReal(item.FK_Flow, item.WorkID, true);
            }
            #endregion  Delete the following sub-processes of the process .

            BP.DA.Log.DefaultLogWriteLineInfo("@[" + fl.Name + "] Flow is [" + BP.Web.WebUser.No + BP.Web.WebUser.Name + "] Delete ,WorkID[" + workID + "].");
            return " You have completed the process of being deleted successfully .";
        }
        /// <summary>
        ///  Remove the child thread 
        /// </summary>
        /// <returns> Returns to remove results .</returns>
        private string DoDeleteSubThreak(bool isDelSubFlow)
        {
            WorkNode wn = this.GetCurrentWorkNode();
            Emp empOfWorker = wn.HisWork.RecOfEmp;

            #region  Normal delete information .
            BP.DA.Log.DefaultLogWriteLineInfo("@[" + this.HisFlow.Name + "] Flow is [" + BP.Web.WebUser.No + BP.Web.WebUser.Name + "] Delete ,WorkID[" + this.WorkID + "].");
            string msg = "";
            try
            {
                Int64 workId = this.WorkID;
                string flowNo = this.HisFlow.No;
            }
            catch (Exception ex)
            {
                throw new Exception(" Acquisition process  ID  And process ID   Error ." + ex.Message);
            }

            try
            {
                //  Delete quality assessment information .
                DBAccess.RunSQL("DELETE FROM WF_CHEval WHERE WorkID=" + this.WorkID); //  Delete the data quality assessment .

                //  Delete CC information .
                DBAccess.RunSQL("DELETE FROM WF_CCList WHERE WorkID=" + this.WorkID);

                //  Delete the document information .
                DBAccess.RunSQL("DELETE FROM WF_Bill WHERE WorkID=" + this.WorkID);
                //  Delete return .
                DBAccess.RunSQL("DELETE FROM WF_ReturnWork WHERE WorkID=" + this.WorkID);
                //  Delete transfer .
                // DBAccess.RunSQL("DELETE FROM WF_ForwardWork WHERE WorkID=" + this.WorkID);

                // Remove it work .
                //DBAccess.RunSQL("DELETE FROM WF_GenerFH WHERE  FID=" + this.WorkID + " AND FK_Flow='" + this.HisFlow.No + "'");
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow WHERE (WorkID=" + this.WorkID + " ) AND FK_Flow='" + this.HisFlow.No + "'");
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkerList WHERE (WorkID=" + this.WorkID + " ) AND FK_Flow='" + this.HisFlow.No + "'");

                if (msg != "")
                    Log.DebugWriteInfo(msg);
            }
            catch (Exception ex)
            {
                string err = "@ Delete Workflow [" + this.HisStartWork.OID + "," + this.HisStartWork.Title + "] Err " + ex.Message;
                Log.DefaultLogWriteLine(LogType.Error, err);
                throw new Exception(err);
            }
            string info = "@ Delete process deleted successfully ";
            #endregion  Normal delete information .

            #region  Problem separation process to remove the problem completion rate .
            if (1 == 2)
            {
                /*  There is no need , Because the diversion point , Only needs to calculate completion rates . */
                string sql = "";
                /* 
                 *  Get stopover taken out , Did not have any children get to explain the position of thread reaches confluence .
                 */
                sql = "SELECT FK_Node FROM WF_GenerWorkerList WHERE WorkID=" + this.FID + " AND IsPass=3";
                int fk_node = DBAccess.RunSQLReturnValInt(sql, 0);
                if (fk_node != 0)
                {
                    /*  That it is a standby state  */
                    Node nextNode = new Node(fk_node);
                    if (nextNode.PassRate > 0)
                    {
                        /*  Found pending node on a point  */
                        Nodes priNodes = nextNode.FromNodes;
                        if (priNodes.Count != 1)
                            throw new Exception("@ Did not realize the needs of sub-processes different threads .");

                        Node priNode = (Node)priNodes[0];

                        #region  Treatment completion rate 
                        sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" + priNode.NodeID + " AND FID=" + this.FID + " AND IsPass=1";
                        decimal ok = (decimal)DBAccess.RunSQLReturnValInt(sql);
                        sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" + priNode.NodeID + " AND FID=" + this.FID;
                        decimal all = (decimal)DBAccess.RunSQLReturnValInt(sql);
                        if (all == 0)
                        {
                            /* Explanation : All sub-threads have been killed ,  It should be the end of the whole process .*/
                            WorkFlow wf = new WorkFlow(this.HisFlow, this.FID);
                            info += "@ All the sub-thread has ended .";
                            info += "@ End of the main flow of information .";
                            info += "@" + wf.DoFlowOver(ActionType.FlowOver, " Confluence process ends ", null, null);
                        }

                        decimal passRate = ok / all * 100;
                        if (nextNode.PassRate <= passRate)
                        {
                            /* Description All the staff have completed , Let confluence display it .*/
                            DBAccess.RunSQL("UPDATE WF_GenerWorkerList SET IsPass=0  WHERE IsPass=3  AND WorkID=" + this.FID + " AND FK_Node=" + fk_node);
                        }
                        #endregion  Treatment completion rate 
                    }
                } /*  Standby state judge has ended .*/

                if (fk_node == 0)
                {
                    /*  Explanation : Do not wait to start working to find the confluence of the node . */
                    GenerWorkFlow gwf = new GenerWorkFlow(this.FID);
                    Node fND = new Node(gwf.FK_Node);
                    switch (fND.HisNodeWorkType)
                    {
                        case NodeWorkType.WorkHL: /* The main flow to the confluence point of the run */
                            break;
                        default:
                            ///*  Solving process when you delete the last child should have to remove the dry process .*/
                            //sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" +this.HisGenerWorkFlow +" AND FID=" + this.FID;
                            //int num = DBAccess.RunSQLReturnValInt(sql);
                            //if (num == 0)
                            //{
                            //    /* Description no child process , On the implementation of this process should be completed .*/
                            //    WorkFlow wf = new WorkFlow(this.HisFlow, this.FID);
                            //    info += "@ All the sub-thread has ended .";
                            //    info += "@ End of the main flow of information .";
                            //    info += "@" + wf.DoFlowOver(ActionType.FlowOver, " Primary process ends ");
                            //}
                            break;
                    }
                }
            }
            #endregion

            #region  Written to delete the log .
            wn.AddToTrack(ActionType.DeleteSubThread, empOfWorker.No, empOfWorker.Name,
             wn.HisNode.NodeID,
             wn.HisNode.Name, " Child thread :" + BP.Web.WebUser.Name + " Delete .");
            #endregion  Written to delete the log .

            return " Child thread was deleted successfully .";
        }
        /// <summary>
        ///  Deletion process has been completed 
        /// </summary>
        /// <param name="flowNo"> Process ID </param>
        /// <param name="workid"> The work ID</param>
        /// <param name="isDelSubFlow"> Delete sub-processes </param>
        /// <returns> Remove the error will be thrown </returns>
        public static void DeleteFlowByReal(string flowNo, Int64 workid, bool isDelSubFlow)
        {
            BP.WF.Flow fl = new Flow(flowNo);
            // Inspection process is completed , If you do not complete calls workflow Delete Process .
            GenerWorkFlow gwf = new GenerWorkFlow();
            gwf.WorkID = workid;
            if (gwf.RetrieveFromDBSources() != 0)
            {
                if (gwf.WFState != WFState.Complete)
                {
                    WorkFlow wf = new WorkFlow(flowNo, workid);
                    wf.DoDeleteWorkFlowByReal(isDelSubFlow);
                    return;
                }
            }

            #region  Data deletion process forms .
            FrmNodes fns = new FrmNodes();
            fns.Retrieve(FrmNodeAttr.FK_Flow, flowNo);
            string strs = "";
            foreach (FrmNode nd in fns)
            {
                if (strs.Contains("@" + nd.FK_Frm) == true)
                    continue;

                strs += "@" + nd.FK_Frm + "@";
                try
                {
                    MapData md = new MapData(nd.FK_Frm);
                    DBAccess.RunSQL("DELETE FROM " + md.PTable + " WHERE OID=" + workid);
                }
                catch
                {
                }
            }
            #endregion  Data deletion process forms .

            // Delete process data .
            DBAccess.RunSQL("DELETE FROM ND" + int.Parse(flowNo) + "Track WHERE WorkID=" + workid);
            DBAccess.RunSQL("DELETE FROM " + fl.PTable + " WHERE OID=" + workid);
            DBAccess.RunSQL("DELETE FROM WF_CHEval WHERE  WorkID=" + workid); //  Delete the data quality assessment .

            #region  Normal delete information .
            BP.DA.Log.DefaultLogWriteLineInfo("@[" + fl.Name + "] Flow is [" + BP.Web.WebUser.No + BP.Web.WebUser.Name + "] Delete ,WorkID[" + workid + "].");
            string msg = "";

            //  Delete the document information .
            DBAccess.RunSQL("DELETE FROM WF_CCList WHERE WorkID=" + workid);
            //  Delete the document information .
            DBAccess.RunSQL("DELETE FROM WF_Bill WHERE WorkID=" + workid);
            //  Delete return .
            DBAccess.RunSQL("DELETE FROM WF_ReturnWork WHERE WorkID=" + workid);

            // Remove it work .
            DBAccess.RunSQL("DELETE FROM WF_GenerFH WHERE  FID=" + workid + " AND FK_Flow='" + flowNo + "'");
            DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow WHERE (WorkID=" + workid + " OR FID=" + workid + " ) AND FK_Flow='" + flowNo + "'");
            DBAccess.RunSQL("DELETE FROM WF_GenerWorkerList WHERE (WorkID=" + workid + " OR FID=" + workid + " ) AND FK_Flow='" + flowNo + "'");

            // Delete all the data on the node .
            Nodes nds = new Nodes(flowNo); // this.HisFlow.HisNodes;
            foreach (Node nd in nds)
            {
                try
                {
                    DBAccess.RunSQL("DELETE FROM ND" + nd.NodeID + " WHERE OID=" + workid + " OR FID=" + workid);
                }
                catch (Exception ex)
                {
                    msg += "@ delete data error " + ex.Message;
                }
            }
            if (msg != "")
            {
                Log.DebugWriteInfo(msg);
            }
            #endregion  Normal delete information .
        }
        /// <summary>
        ///  Completely delete process 
        /// </summary>
        /// <param name="isDelSubFlow"> Do you want to delete the sub-processes </param>
        /// <returns> Deleted message </returns>
        public string DoDeleteWorkFlowByReal(bool isDelSubFlow)
        {
            if (this.FID != 0)
                return DoDeleteSubThreak(isDelSubFlow);

            string info = "";
            WorkNode wn = this.GetCurrentWorkNode();

            //  Delete the pre-event processing .
            wn.HisFlow.DoFlowEventEntity(EventListOfNode.BeforeFlowDel, wn.HisNode, wn.HisWork, null);

            #region  Data deletion process forms .
            FrmNodes fns = new FrmNodes();
            fns.Retrieve(FrmNodeAttr.FK_Flow, this.HisFlow.No);
            string strs = "";
            foreach (FrmNode nd in fns)
            {
                if (strs.Contains("@" + nd.FK_Frm) == true)
                    continue;

                strs += "@" + nd.FK_Frm + "@";
                try
                {
                    MapData md = new MapData(nd.FK_Frm);
                    DBAccess.RunSQL("DELETE FROM " + md.PTable + " WHERE OID=" + this.WorkID);
                }
                catch
                {
                }
            }
            #endregion  Data deletion process forms .

            // Delete process data .
            DBAccess.RunSQL("DELETE FROM ND" + int.Parse(this.HisFlow.No) + "Track WHERE WorkID=" + this.WorkID);
            DBAccess.RunSQL("DELETE FROM " + this.HisFlow.PTable + " WHERE OID=" + this.WorkID);
            DBAccess.RunSQL("DELETE FROM WF_CHEval WHERE  WorkID=" + this.WorkID); //  Delete the data quality assessment .

            #region  Normal delete information .
            BP.DA.Log.DefaultLogWriteLineInfo("@[" + this.HisFlow.Name + "] Flow is [" + BP.Web.WebUser.No + BP.Web.WebUser.Name + "] Delete ,WorkID[" + this.WorkID + "].");
            string msg = "";
            try
            {
                Int64 workId = this.WorkID;
                string flowNo = this.HisFlow.No;
            }
            catch (Exception ex)
            {
                throw new Exception(" Acquisition process  ID  And process ID   Error ." + ex.Message);
            }

            try
            {
                //  Delete the document information .
                DBAccess.RunSQL("DELETE FROM WF_CCList WHERE WorkID=" + this.WorkID);
                //  Delete the document information .
                DBAccess.RunSQL("DELETE FROM WF_Bill WHERE WorkID=" + this.WorkID);
                //  Delete return .
                DBAccess.RunSQL("DELETE FROM WF_ReturnWork WHERE WorkID=" + this.WorkID);

                // Remove it work .
                DBAccess.RunSQL("DELETE FROM WF_GenerFH WHERE  FID=" + this.WorkID + " AND FK_Flow='" + this.HisFlow.No + "'");
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow WHERE (WorkID=" + this.WorkID + " OR FID=" + this.WorkID + " ) AND FK_Flow='" + this.HisFlow.No + "'");
                DBAccess.RunSQL("DELETE FROM WF_GenerWorkerList WHERE (WorkID=" + this.WorkID + " OR FID=" + this.WorkID + " ) AND FK_Flow='" + this.HisFlow.No + "'");

                // Delete all the data on the node .
                Nodes nds = this.HisFlow.HisNodes;
                foreach (Node nd in nds)
                {
                    try
                    {
                        DBAccess.RunSQL("DELETE FROM ND" + nd.NodeID + " WHERE OID=" + this.WorkID + " OR FID=" + this.WorkID);
                    }
                    catch (Exception ex)
                    {
                        msg += "@ delete data error " + ex.Message;
                    }
                }
                if (msg != "")
                {
                    Log.DebugWriteInfo(msg);
                }
            }
            catch (Exception ex)
            {
                string err = "@ Delete Workflow [" + this.HisStartWork.OID + "," + this.HisStartWork.Title + "] Err " + ex.Message;
                Log.DefaultLogWriteLine(LogType.Error, err);
                throw new Exception(err);
            }
            info = "@ Delete process deleted successfully ";
            #endregion  Normal delete information .

            #region  Problem separation process to remove the problem completion rate .
            if (this.FID != 0)
            {
                string sql = "";
                /* 
                 *  Get stopover taken out , Did not have any children get to explain the position of thread reaches confluence .
                 */
                sql = "SELECT FK_Node FROM WF_GenerWorkerList WHERE WorkID=" + wn.HisWork.FID + " AND IsPass=3";
                int fk_node = DBAccess.RunSQLReturnValInt(sql, 0);
                if (fk_node != 0)
                {
                    /*  That it is a standby state  */
                    Node nextNode = new Node(fk_node);
                    if (nextNode.PassRate > 0)
                    {
                        /*  Found pending node on a point  */
                        Nodes priNodes = nextNode.FromNodes;
                        if (priNodes.Count != 1)
                            throw new Exception("@ Did not realize the needs of sub-processes different threads .");

                        Node priNode = (Node)priNodes[0];

                        #region  Treatment completion rate 
                        sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" + priNode.NodeID + " AND FID=" + wn.HisWork.FID + " AND IsPass=1";
                        decimal ok = (decimal)DBAccess.RunSQLReturnValInt(sql);
                        sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" + priNode.NodeID + " AND FID=" + wn.HisWork.FID;
                        decimal all = (decimal)DBAccess.RunSQLReturnValInt(sql);
                        if (all == 0)
                        {
                            /* Explanation : All sub-threads have been killed ,  It should be the end of the whole process .*/
                            WorkFlow wf = new WorkFlow(this.HisFlow, this.FID);
                            info += "@ All the sub-thread has ended .";
                            info += "@ End of the main flow of information .";
                            info += "@" + wf.DoFlowOver(ActionType.FlowOver, " Confluence process ends ", null, null);
                        }

                        decimal passRate = ok / all * 100;
                        if (nextNode.PassRate <= passRate)
                        {
                            /* Description All the staff have completed , Let confluence display it .*/
                            DBAccess.RunSQL("UPDATE WF_GenerWorkerList SET IsPass=0  WHERE IsPass=3  AND WorkID=" + wn.HisWork.FID + " AND FK_Node=" + fk_node);
                        }
                        #endregion  Treatment completion rate 
                    }
                } /*  Standby state judge has ended .*/

                if (fk_node == 0)
                {
                    /*  Explanation : Do not wait to start working to find the confluence of the node . */
                    GenerWorkFlow gwf = new GenerWorkFlow(this.FID);
                    Node fND = new Node(gwf.FK_Node);
                    switch (fND.HisNodeWorkType)
                    {
                        case NodeWorkType.WorkHL: /* The main flow to the confluence point of the run */
                            break;
                        default:
                            /*  Solving process when you delete the last child should have to remove the dry process .*/
                            sql = "SELECT COUNT(*) AS Num FROM WF_GenerWorkerList WHERE FK_Node=" + wn.HisNode.NodeID + " AND FID=" + wn.HisWork.FID;
                            int num = DBAccess.RunSQLReturnValInt(sql);
                            if (num == 0)
                            {
                                /* Description no child process , On the implementation of this process should be completed .*/
                                WorkFlow wf = new WorkFlow(this.HisFlow, this.FID);
                                info += "@ All the sub-thread has ended .";
                                info += "@ End of the main flow of information .";
                                info += "@" + wf.DoFlowOver(ActionType.FlowOver, " Primary process ends ", null, null);
                            }
                            break;
                    }
                }
            }
            #endregion

            #region  Delete the following sub-processes of the process .
            if (isDelSubFlow)
            {
                GenerWorkFlows gwfs = new GenerWorkFlows();
                gwfs.Retrieve(GenerWorkFlowAttr.PWorkID, this.WorkID);

                foreach (GenerWorkFlow item in gwfs)
                    BP.WF.Dev2Interface.Flow_DoDeleteFlowByReal(item.FK_Flow, item.WorkID, true);
            }
            #endregion  Delete the following sub-processes of the process .


            //  Processing Delete hou Event .
            wn.HisFlow.DoFlowEventEntity(EventListOfNode.AfterFlowDel, wn.HisNode, wn.HisWork, null);
            return info;
        }
        /// <summary>
        ///  Delete workflow log , And retain the trajectory .
        /// </summary>
        /// <param name="isDelSubFlow"> Do you want to delete the sub-processes </param>
        /// <returns></returns>
        public string DoDeleteWorkFlowByWriteLog(string info, bool isDelSubFlow)
        {
            GERpt rpt = new GERpt("ND" + int.Parse(this.HisFlow.No) + "Rpt", this.WorkID);
            WorkFlowDeleteLog log = new WorkFlowDeleteLog();
            log.OID = this.WorkID;
            try
            {
                log.Copy(rpt);
                log.DeleteDT = DataType.CurrentDataTime;
                log.OperDept = WebUser.FK_Dept;
                log.OperDeptName = WebUser.FK_DeptName;
                log.Oper = WebUser.No;
                log.DeleteNote = info;
                log.OID = this.WorkID;
                log.FK_Flow = this.HisFlow.No;
                log.InsertAsOID(log.OID);
                return DoDeleteWorkFlowByReal(isDelSubFlow);
            }
            catch (Exception ex)
            {
                log.CheckPhysicsTable();
                log.Delete();
                return ex.StackTrace;
            }
        }

        #region  Forced termination process \ Delete   Or use the recovery process ,
        /// <summary>
        ///  Recovery process .
        /// </summary>
        /// <param name="msg"> Reply reasons process </param>
        public void DoComeBackWorkFlow(string msg)
        {
            try
            {
                // Set generated workflow 
                GenerWorkFlow gwf = new GenerWorkFlow(this.WorkID);
                gwf.WFState = WFState.Runing;
                gwf.DirectUpdate();

                //  Increase news  
                WorkNode wn = this.GetCurrentWorkNode();
                GenerWorkerLists wls = new GenerWorkerLists(wn.HisWork.OID, wn.HisNode.NodeID);
                if (wls.Count == 0)
                    throw new Exception("@ Error recovery process , Workers produce a list of ");
                BP.WF.MsgsManager.AddMsgs(wls, " Recovery Process ", wn.HisNode.Name, " Reply processes ");
            }
            catch (Exception ex)
            {
                Log.DefaultLogWriteLine(LogType.Error, "@ Error recovery process ." + ex.Message);
                throw new Exception("@ Error recovery process ." + ex.Message);
            }
        }
        #endregion

        /// <summary>
        ///  Get the current work in progress .
        /// </summary>
        /// <returns></returns>		 
        public WorkNode GetCurrentWorkNode()
        {
            int currNodeID = 0;
            GenerWorkFlow gwf = new GenerWorkFlow();
            gwf.WorkID = this.WorkID;
            if (gwf.RetrieveFromDBSources() == 0)
            {
                this.DoFlowOver(ActionType.FlowOver, " Non-normal end , The current process does not find Records .", null, null);
                throw new Exception("@" + string.Format(" Workflow {0} Has been completed .", this.HisStartWork.Title));
            }

            Node nd = new Node(gwf.FK_Node);
            Work work = nd.HisWork;
            work.OID = this.WorkID;
            work.NodeID = nd.NodeID;
            work.SetValByKey("FK_Dept", BP.Web.WebUser.FK_Dept);
            if (work.RetrieveFromDBSources() == 0)
            {
                Log.DefaultLogWriteLineError("@WorkID=" + this.WorkID + ",FK_Node=" + gwf.FK_Node + ". Check it out should not appear to work ."); //  No data found current work node , Unknown exception process .
                work.Rec = BP.Web.WebUser.No;
                try
                {
                    work.Insert();
                }
                catch (Exception ex)
                {
                    Log.DefaultLogWriteLineError("@ No data found current work node , Unknown exception process " + ex.Message + ", Should not appear "); //  No data found current work node 
                }
            }
            work.FID = gwf.FID;

            WorkNode wn = new WorkNode(work, nd);
            return wn;
        }
        /// <summary>
        ///  End nodes shunt 
        /// </summary>
        /// <param name="fid"></param>
        /// <returns></returns>
        public string DoFlowOverFeiLiu(GenerWorkFlow gwf)
        {
            //  Check out the process has not been completed less .
            int i = BP.DA.DBAccess.RunSQLReturnValInt("SELECT COUNT(*) FROM WF_GenerWorkFlow WHERE FID=" + gwf.FID + " AND WFState!=1");
            switch (i)
            {
                case 0:
                    throw new Exception("@ Should not be wrong .");
                case 1:
                    BP.DA.DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow  WHERE FID=" + gwf.FID + " OR WorkID=" + gwf.FID);
                    BP.DA.DBAccess.RunSQL("DELETE FROM WF_GenerWorkerlist WHERE FID=" + gwf.FID + " OR WorkID=" + gwf.FID);
                    BP.DA.DBAccess.RunSQL("DELETE FROM WF_GenerFH WHERE FID=" + gwf.FID);

                    StartWork wk = this.HisFlow.HisStartNode.HisWork as StartWork;
                    wk.OID = gwf.FID;
                    wk.Update();

                    return "@ The current work has been completed , All work on this process has been completed .";
                default:
                    BP.DA.DBAccess.RunSQL("UPDATE WF_GenerWorkFlow SET WFState=1 WHERE WorkID=" + this.WorkID);
                    BP.DA.DBAccess.RunSQL("UPDATE WF_GenerWorkerlist SET IsPass=1 WHERE WorkID=" + this.WorkID);
                    return "@ The current work has been completed .";
            }
        }
        /// <summary>
        ///  Processing sub-process is completed .
        /// </summary>
        /// <returns></returns>
        public string DoFlowSubOver()
        {
            GenerWorkFlow gwf = new GenerWorkFlow(this.WorkID);
            Node nd = new Node(gwf.FK_Node);

            DBAccess.RunSQL("DELETE FROM WF_GenerWorkFlow   WHERE WorkID=" + this.WorkID);
            DBAccess.RunSQL("DELETE FROM WF_GenerWorkerlist WHERE WorkID=" + this.WorkID);

            string sql = "SELECT count(*) FROM WF_GenerWorkFlow WHERE  FID=" + this.FID;
            int num = DBAccess.RunSQLReturnValInt(sql);
            if (DBAccess.RunSQLReturnValInt(sql) == 0)
            {
                /* Description This is the last one */
                WorkFlow wf = new WorkFlow(gwf.FK_Flow, this.FID);
                wf.DoFlowOver(ActionType.FlowOver, " Sub process ends ", null, null);
                return "@ The current sub-processes have been completed , Primary process has been completed .";
            }
            else
            {
                return "@ The current sub-processes have been completed , There main flow (" + num + ") Sub-process is not completed .";
            }
        }
        /// <summary>
        ///  Let the father process is automatically sent to the next step up .
        /// </summary>
        public string LetParentFlowAutoSendNextSetp()
        {
            if (this.HisGenerWorkFlow.PWorkID == 0)
                return "";

            if (this.HisFlow.IsAutoSendSubFlowOver == false)
                return "";

            //  Check whether it is the last one .
            int num = BP.WF.Dev2Interface.Flow_NumOfSubFlowRuning(this.HisGenerWorkFlow.PWorkID, this.HisGenerWorkFlow.WorkID);
            if (num != 0)
                return "";

            // Check whether there is the parent process ?
            GenerWorkFlow pGWF = new GenerWorkFlow();
            pGWF.WorkID = this.HisGenerWorkFlow.PWorkID;
            if (pGWF.RetrieveFromDBSources() == 0)
                return ""; //  Parent process has been deleted it can not be executed .

            if (pGWF.WFState == WFState.Complete)
                return ""; // Parent process has been completed can not be executed .

            // Stay current node checks whether the parent process or sub-process of initiating node ?
            if (this.HisGenerWorkFlow.PNodeID != pGWF.FK_Node)
                return "";

            // The process to find the person calling , Do not judge here , If more than one person to handle the node , People can only find the current deal .
            //  string pEmp = DBAccess.RunSQLReturnStringIsNull("SELECT FK_Emp FROM WF_GenerWorkerList WHERE WorkID=" + this.HisGenerWorkFlow.PWorkID + " AND FK_Node=" + this.HisGenerWorkFlow.FK_Node + " AND IsPass=0", null);
            //NDXRptBaseAttr

            //  Because already on him a direct update so there need to be queried after performing the update .
            this.HisGenerWorkFlow.RetrieveFromDBSources();

            try
            {
                // Screwdriver adjustment process to obtain staff .
                string pEmp = this.HisGenerWorkFlow.PEmp;
                if (string.IsNullOrEmpty(pEmp) == true)
                    throw new Exception("@ Staff did not find the process of adjusting screwdriver .");
                Emp emp = new Emp();
                emp.No = pEmp;
                if (emp.RetrieveFromDBSources() == 0)
                    throw new Exception("@ Staff numbers lifted on sub-processes (" + pEmp + ") No longer exists , Unable to start the parent process .");

                // Change the state of the current node , Otherwise, if you do a set parent process so that all the sub-processes in order to run after the transmission is complete after , Can not be allowed to send a .
                this.HisGenerWorkFlow.WFState = WFState.Complete;
                this.HisGenerWorkFlow.DirectUpdate();

                //  Let the current staff sent down , But this must not be sent to check the Send As permission , Otherwise it an error , Can not be sent down .
                SendReturnObjs objs = BP.WF.Dev2Interface.Node_SendWork(this.HisGenerWorkFlow.PFlowNo, pGWF.WorkID, null, null, 0, null,
                    emp.No, emp.Name, emp.FK_Dept, emp.FK_DeptText,null);

                this.HisGenerWorkFlow.WFState = WFState.Complete;
                this.HisGenerWorkFlow.DirectUpdate();

                return "@ The current node is the last child of a process flow ,  Success for the parent process to run to the next node ." + objs.ToMsgOfHtml();
            }
            catch (Exception ex)
            {
                this.HisGenerWorkFlow.WFState = WFState.Complete;
                this.HisGenerWorkFlow.DirectUpdate();
                return "@ After the last child process is complete , Let the parent process when a node is automatically sent , Error :" + ex.Message;
            }
        }
        /// <summary>
        ///  The completion of the implementation process 
        /// </summary>
        /// <param name="at"></param>
        /// <param name="stopMsg"></param>
        /// <returns></returns>
        public string DoFlowOver(ActionType at, string stopMsg, Node currNode, GERpt rpt)
        {
            // Call before the end of the event .
            this.HisFlow.DoFlowEventEntity(EventListOfNode.FlowOverBefore, currNode, rpt, null);

            if (string.IsNullOrEmpty(stopMsg))
                stopMsg += " Process ends ";

            string exp = currNode.FocusField;
            if (exp.Length > 1)
            {
                if (rpt != null)
                    stopMsg += Glo.DealExp(exp, rpt, null);
            }

            string msg = "";
            if (this.IsMainFlow == false)
            {
                /*  Processing sub-process is completed */
                return this.DoFlowSubOver();
            }

            #region  Processing summary list of .
            Node currND = new Node(this.HisGenerWorkFlow.FK_Node);

            // Detail data processing copy Issue .  First check : The current node ги The last node гй Is there a list .
            MapDtls dtls = currND.MapData.MapDtls; // new MapDtls("ND" + nd.NodeID);
            int i = 0;
            foreach (MapDtl dtl in dtls)
            {
                i++;
                //  Check out the list of data .
                GEDtls dtlDatas = new GEDtls(dtl.No);
                dtlDatas.Retrieve(GEDtlAttr.RefPK, this.WorkID);

                GEDtl geDtl = null;
                try
                {
                    //  Create a Rpt Object .
                    geDtl = new GEDtl("ND" + int.Parse(this.HisFlow.No) + "RptDtl" + i.ToString());
                    geDtl.ResetDefaultVal();
                }
                catch
                {
#warning  Here in need of repair .
                    continue;
                }
            }
            this._IsComplete = 1;
            #endregion  Processing summary list of .

            #region  Subsequent processing business .

            string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;
            Paras ps = new Paras();
            ps.SQL = "DELETE FROM WF_GenerFH WHERE FID=" + dbstr + "FID";
            ps.Add(GenerFHAttr.FID, this.WorkID);
            DBAccess.RunSQL(ps);

            if (Glo.IsDeleteGenerWorkFlow == true)
            {
                //  Delete the registry data flow ?
                ps = new Paras();
                ps.SQL = "DELETE FROM WF_GenerWorkFlow WHERE WorkID=" + dbstr + "WorkID1 OR FID=" + dbstr + "WorkID2 ";
                ps.Add("WorkID1", this.WorkID);
                ps.Add("WorkID2", this.WorkID);
                DBAccess.RunSQL(ps);
            }
            else
            {
                // Participants obtained , To facilitate the work already completed inquiry .
                ps = new Paras();
                ps.SQL = "SELECT EmpFrom FROM ND" + int.Parse(this._HisFlow.No) + "Track WHERE WorkID=" + dbstr + "WorkID OR FID=" + dbstr + "FID ";
                ps.Add("WorkID", this.WorkID);
                ps.Add("FID", this.WorkID);
                DataTable dt = BP.DA.DBAccess.RunSQLReturnTable(ps);
                string emps = "";
                foreach (DataRow dr in dt.Rows)
                {
                    if (emps.Contains("@" + dr[0].ToString()) == true)
                        continue;
                    emps += "@" + dr[0].ToString();
                }
                emps = emps + "@";

                // Registration information update process .
                ps = new Paras();
                ps.SQL = "UPDATE WF_GenerWorkFlow SET WFState=" + dbstr + "WFState,WFSta=" + dbstr + "WFSta,Emps=" + dbstr + "Emps,MyNum=1 WHERE WorkID=" + dbstr + "WorkID ";
                ps.Add("WFState", (int)WFState.Complete);
                ps.Add("WFSta", (int)WFSta.Complete);
                ps.Add("Emps", emps);
                ps.Add("WorkID", this.WorkID);
                DBAccess.RunSQL(ps);
            }

            //  Clear worker .
            ps = new Paras();
            ps.SQL = "DELETE FROM WF_GenerWorkerlist WHERE WorkID=" + dbstr + "WorkID1 OR FID=" + dbstr + "WorkID2 ";
            ps.Add("WorkID1", this.WorkID);
            ps.Add("WorkID2", this.WorkID);
            DBAccess.RunSQL(ps);

            //  Setting process completion status .
            ps = new Paras();
            ps.SQL = "UPDATE " + this.HisFlow.PTable + " SET WFState=" + dbstr + "WFState WHERE OID=" + dbstr + "OID";
            ps.Add("WFState", (int)WFState.Complete);
            ps.Add("OID", this.WorkID);
            DBAccess.RunSQL(ps);

            // Join track .
            WorkNode wn = new WorkNode(WorkID, this.HisGenerWorkFlow.FK_Node);
            wn.AddToTrack(at, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name,
                    stopMsg);

            // After the end of the event call .
            this.HisFlow.DoFlowEventEntity(EventListOfNode.FlowOverAfter, currNode, rpt, null);
            #endregion  Subsequent processing business .

            // Finally, a check is performed after sending a child process , Whether success , The process should be ended .
            msg += this.LetParentFlowAutoSendNextSetp();

            //   string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;

            #region  Deal with audit issues , Update audit opinion in the audit component into   To node , To staff .
            ps = new Paras();
            ps.SQL = "UPDATE ND" + int.Parse(currNode.FK_Flow) + "Track SET NDTo=" + dbstr + "NDTo,NDToT=" + dbstr + "NDToT,EmpTo=" + dbstr + "EmpTo,EmpToT=" + dbstr + "EmpToT WHERE NDFrom=" + dbstr + "NDFrom AND EmpFrom=" + dbstr + "EmpFrom AND WorkID=" + dbstr + "WorkID AND ActionType=" + (int)ActionType.WorkCheck;
            ps.Add(TrackAttr.NDTo, currNode.NodeID);
            ps.Add(TrackAttr.NDToT, "");
            ps.Add(TrackAttr.EmpTo, "");
            ps.Add(TrackAttr.EmpToT, "");

            ps.Add(TrackAttr.NDFrom, currNode.NodeID);
            ps.Add(TrackAttr.EmpFrom, WebUser.No);
            ps.Add(TrackAttr.WorkID, this.WorkID);
            BP.DA.DBAccess.RunSQL(ps);
            #endregion  Deal with audit issues .


            //if (string.IsNullOrEmpty(msg) == true)
            //    msg = " Successful conclusion of the process .";
            return msg;
        }
        public string GenerFHStartWorkInfo()
        {
            string msg = "";
            DataTable dt = DBAccess.RunSQLReturnTable("SELECT Title,RDT,Rec,OID FROM ND" + this.StartNodeID + " WHERE FID=" + this.FID);
            switch (dt.Rows.Count)
            {
                case 0:
                    Node nd = new Node(this.StartNodeID);
                    throw new Exception("@ No data found they start node , Process Exception .FID=" + this.FID + ", Node :" + nd.Name + " Node ID:" + nd.NodeID);
                case 1:
                    msg = string.Format("@ Sponsor : {0}   Date :{1}  Initiated the process   Title :{2} , Has been successfully completed .",
                        dt.Rows[0]["Rec"].ToString(), dt.Rows[0]["RDT"].ToString(), dt.Rows[0]["Title"].ToString());
                    break;
                default:
                    msg = "@ The following (" + dt.Rows.Count + ") Bit staff initiated the process has been completed .";
                    foreach (DataRow dr in dt.Rows)
                    {
                        msg += "<br> Sponsor :" + dr["Rec"] + "  Launch date :" + dr["RDT"] + "  Title :" + dr["Title"] + "<a href='./../../WF/WFRpt.aspx?WorkID=" + dr["OID"] + "&FK_Flow=" + this.HisFlow.No + "' target=_blank> Detailed ...</a>";
                    }
                    break;
            }
            return msg;
        }
        public int StartNodeID
        {
            get
            {
                return int.Parse(this.HisFlow.No + "01");
            }
        }
        /// <summary>
        ///   Cc 
        /// </summary>
        /// <param name="dt"></param>
        public string CCTo(DataTable dt)
        {
            if (dt.Rows.Count == 0)
                return "";

            string emps = "";
            string empsExt = "";

            string ip = "127.0.0.1";
            System.Net.IPAddress[] addressList = System.Net.Dns.GetHostByName(System.Net.Dns.GetHostName()).AddressList;
            if (addressList.Length > 1)
                ip = addressList[1].ToString();
            else
                ip = addressList[0].ToString();


            foreach (DataRow dr in dt.Rows)
            {
                string no = dr[0].ToString();
                string name = dr[1].ToString();

                emps += BP.WF.Glo.DealUserInfoShowModel(no, name);
            }

            Paras pss = new Paras();
            pss.Add("Sender", BP.Web.WebUser.No);
            pss.Add("Receivers", emps);
            pss.Add("Title", " Workflow Cc : Working Title :" + this.HisFlow.Name + ", The final disposition of people :" + BP.Web.WebUser.Name);
            pss.Add("Context", " Work trajectory  http://" + ip + "/WF/WFRpt.aspx?WorkID=" + this.WorkID + "&FID=0");

            try
            {
                DBAccess.RunSP("CCstaff", pss);
                return "@" + empsExt;
            }
            catch (Exception ex)
            {
                return "@ Cc error , CC did not put that information into the process (" + empsExt + ") Contact your system administrator to check the abnormal " + ex.Message;
            }
        }
        /// <summary>
        ///  Execution freeze 
        /// </summary>
        /// <param name="msg"> Blocking Reasons </param>
        public string DoFix(string fixMsg)
        {
            if (this.HisGenerWorkFlow.WFState == WFState.Fix)
                throw new Exception("@ The current state is already frozen, you can not perform a re-freeze .");

            if (string.IsNullOrEmpty(fixMsg))
                fixMsg = "╬▐";


            ///*  Get its workers , Send a message to them .*/
            //GenerWorkerLists wls = new GenerWorkerLists(this.WorkID, this.HisFlow.No);

            //string url = Glo.ServerIP + "/" + this.VirPath + this.AppType + "/WorkOpt/OneWork/Track.aspx?FK_Flow=" + this.HisFlow.No + "&WorkID=" + this.WorkID + "&FID=" + this.HisGenerWorkFlow.FID + "&FK_Node=" + this.HisGenerWorkFlow.FK_Node;
            //string mailDoc = " Details :<A href='" + url + "'> Open process track </A>.";
            //string title = " The work :" + this.HisGenerWorkFlow.Title + " ▒╗" + WebUser.Name + " Freeze " + fixMsg;
            //string emps = "";
            //foreach (GenerWorkerList wl in wls)
            //{
            //    if (wl.IsEnable == false)
            //        continue; // Not sent to the disabled person .

            //    emps += wl.FK_Emp + "," + wl.FK_EmpText + ";";

            //    // Write messages .
            //    BP.WF.Dev2Interface.Port_SendMsg(wl.FK_Emp, title, mailDoc, "Fix" + wl.WorkID, BP.Sys.SMSMsgType.Etc, wl.FK_Flow, wl.FK_Node, wl.WorkID, wl.FID);
            //}

            /*  Carried out  WF_GenerWorkFlow  Freeze . */
            int sta = (int)WFState.Fix;
            string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;
            Paras ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkFlow SET WFState=" + dbstr + "WFState WHERE WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkFlowAttr.WFState, sta);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Update process status report . 
            ps = new Paras();
            ps.SQL = "UPDATE " + this.HisFlow.PTable + " SET WFState=" + dbstr + "WFState WHERE OID=" + dbstr + "OID";
            ps.Add(GERptAttr.WFState, sta);
            ps.Add(GERptAttr.OID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Logging ..
            WorkNode wn = new WorkNode(this.WorkID, this.HisGenerWorkFlow.FK_Node);

            //wn.AddToTrack(ActionType.Info, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name, fixMsg,);

            return " Has been executed successfully freeze ";
        }
        /// <summary>
        ///  Execution unfreeze 
        /// </summary>
        /// <param name="msg"> Blocking Reasons </param>
        public string DoUnFix(string unFixMsg)
        {
            if (this.HisGenerWorkFlow.WFState != WFState.Fix)
                throw new Exception("@ The current non-frozen state, you can not perform unfrozen .");

            if (string.IsNullOrEmpty(unFixMsg))
                unFixMsg = "╬▐";


            ///*  Get its workers , Send a message to them .*/
            //GenerWorkerLists wls = new GenerWorkerLists(this.WorkID, this.HisFlow.No);

            //string url = Glo.ServerIP + "/" + this.VirPath + this.AppType + "/WorkOpt/OneWork/Track.aspx?FK_Flow=" + this.HisFlow.No + "&WorkID=" + this.WorkID + "&FID=" + this.HisGenerWorkFlow.FID + "&FK_Node=" + this.HisGenerWorkFlow.FK_Node;
            //string mailDoc = " Details :<A href='" + url + "'> Open process track </A>.";
            //string title = " The work :" + this.HisGenerWorkFlow.Title + " ▒╗" + WebUser.Name + " Freeze " + unFixMsg;
            //string emps = "";
            //foreach (GenerWorkerList wl in wls)
            //{
            //    if (wl.IsEnable == false)
            //        continue; // Not sent to the disabled person .

            //    emps += wl.FK_Emp + "," + wl.FK_EmpText + ";";

            //    // Write messages .
            //    BP.WF.Dev2Interface.Port_SendMsg(wl.FK_Emp, title, mailDoc, "Fix" + wl.WorkID, BP.Sys.SMSMsgType.Self, wl.FK_Flow, wl.FK_Node, wl.WorkID, wl.FID);
            //}

            /*  Carried out  WF_GenerWorkFlow  Freeze . */
            int sta = (int)WFState.Runing;
            string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;
            Paras ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkFlow SET WFState=" + dbstr + "WFState WHERE WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkFlowAttr.WFState, sta);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Update process status report . 
            ps = new Paras();
            ps.SQL = "UPDATE " + this.HisFlow.PTable + " SET WFState=" + dbstr + "WFState WHERE OID=" + dbstr + "OID";
            ps.Add(GERptAttr.WFState, sta);
            ps.Add(GERptAttr.OID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Logging ..
            WorkNode wn = new WorkNode(this.WorkID, this.HisGenerWorkFlow.FK_Node);
            //wn.AddToTrack(ActionType.Info, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name, unFixMsg);

            return " Has been successfully executed unfrozen :";
        }
        #endregion

        #region  Basic properties 
        /// <summary>
        ///  His node 
        /// </summary>
        private Nodes _HisNodes = null;
        /// <summary>
        ///  Node s
        /// </summary>
        public Nodes HisNodes
        {
            get
            {
                if (this._HisNodes == null)
                    this._HisNodes = this.HisFlow.HisNodes;
                return this._HisNodes;
            }
        }
        /// <summary>
        ///  Work node s( Ordinary working nodes )
        /// </summary>
        private WorkNodes _HisWorkNodesOfWorkID = null;
        /// <summary>
        ///  Work node s
        /// </summary>
        public WorkNodes HisWorkNodesOfWorkID
        {
            get
            {
                if (this._HisWorkNodesOfWorkID == null)
                {
                    this._HisWorkNodesOfWorkID = new WorkNodes();
                    this._HisWorkNodesOfWorkID.GenerByWorkID(this.HisFlow, this.WorkID);
                }
                return this._HisWorkNodesOfWorkID;
            }
        }
        /// <summary>
        ///  Work node s
        /// </summary>
        private WorkNodes _HisWorkNodesOfFID = null;
        /// <summary>
        ///  Work node s
        /// </summary>
        public WorkNodes HisWorkNodesOfFID
        {
            get
            {
                if (this._HisWorkNodesOfFID == null)
                {
                    this._HisWorkNodesOfFID = new WorkNodes();
                    this._HisWorkNodesOfFID.GenerByFID(this.HisFlow, this.FID);
                }
                return this._HisWorkNodesOfFID;
            }
        }
        /// <summary>
        ///  Workflow 
        /// </summary>
        private Flow _HisFlow = null;
        /// <summary>
        ///  Workflow 
        /// </summary>
        public Flow HisFlow
        {
            get
            {
                return this._HisFlow;
            }
        }
        private GenerWorkFlow _HisGenerWorkFlow = null;
        public GenerWorkFlow HisGenerWorkFlow
        {
            get
            {
                if (_HisGenerWorkFlow == null)
                    _HisGenerWorkFlow = new GenerWorkFlow(this.WorkID);
                return _HisGenerWorkFlow;
            }
            set
            {
                _HisGenerWorkFlow = value;
            }
        }
        /// <summary>
        ///  The work ID
        /// </summary>
        private Int64 _WorkID = 0;
        /// <summary>
        ///  The work ID
        /// </summary>
        public Int64 WorkID
        {
            get
            {
                return this._WorkID;
            }
        }
        /// <summary>
        ///  The work ID
        /// </summary>
        private Int64 _FID = 0;
        /// <summary>
        ///  The work ID
        /// </summary>
        public Int64 FID
        {
            get
            {
                return this._FID;
            }
            set
            {
                this._FID = value;
            }
        }
        /// <summary>
        ///  Is River 
        /// </summary>
        public bool IsMainFlow
        {
            get
            {
                if (this.FID != 0 && this.FID != this.WorkID)
                    return false;
                else
                    return true;
            }
        }
        #endregion

        #region  Constructor 
        public WorkFlow(string fk_flow, Int64 wkid)
        {
            this.HisGenerWorkFlow = new GenerWorkFlow();
            this.HisGenerWorkFlow.WorkID = wkid;
            this.HisGenerWorkFlow.Retrieve();
            this._FID = this.HisGenerWorkFlow.FID;
            if (wkid == 0)
                throw new Exception("@ Work not specified ID,  You can not create a workflow .");
            Flow flow = new Flow(fk_flow);
            this._HisFlow = flow;
            this._WorkID = wkid;

        }

        public WorkFlow(Flow flow, Int64 wkid)
        {
            GenerWorkFlow gwf = new GenerWorkFlow();
            gwf.WorkID = wkid;
            gwf.RetrieveFromDBSources();

            this._FID = gwf.FID;
            if (wkid == 0)
                throw new Exception("@ Work not specified ID,  You can not create a workflow .");
            //Flow flow= new Flow(FlowNo);
            this._HisFlow = flow;
            this._WorkID = wkid;
        }
        /// <summary>
        ///  Establish a workflow instance 
        /// </summary>
        /// <param name="flow"> Process No</param>
        /// <param name="wkid"> The work ID</param>
        public WorkFlow(Flow flow, Int64 wkid, Int64 fid)
        {
            this._FID = fid;
            if (wkid == 0)
                throw new Exception("@ Work not specified ID,  You can not create a workflow .");
            //Flow flow= new Flow(FlowNo);
            this._HisFlow = flow;
            this._WorkID = wkid;
        }
        public WorkFlow(string FK_flow, Int64 wkid, Int64 fid)
        {
            this._FID = fid;

            Flow flow = new Flow(FK_flow);
            if (wkid == 0)
                throw new Exception("@ Work not specified ID,  You can not create a workflow .");
            //Flow flow= new Flow(FlowNo);
            this._HisFlow = flow;
            this._WorkID = wkid;
        }
        #endregion

        #region  Public property 

        /// <summary>
        ///  Begin work 
        /// </summary>
        private StartWork _HisStartWork = null;
        /// <summary>
        ///  His work begins .
        /// </summary>
        public StartWork HisStartWork
        {
            get
            {
                if (_HisStartWork == null)
                {
                    StartWork en = (StartWork)this.HisFlow.HisStartNode.HisWork;
                    en.OID = this.WorkID;
                    en.FID = this.FID;
                    if (en.RetrieveFromDBSources() == 0)
                        en.RetrieveFID();
                    _HisStartWork = en;
                }
                return _HisStartWork;
            }
        }
        /// <summary>
        ///  Start working node 
        /// </summary>
        private WorkNode _HisStartWorkNode = null;
        /// <summary>
        ///  His work begins .
        /// </summary>
        public WorkNode HisStartWorkNode
        {
            get
            {
                if (_HisStartWorkNode == null)
                {
                    Node nd = this.HisFlow.HisStartNode;
                    StartWork en = (StartWork)nd.HisWork;
                    en.OID = this.WorkID;
                    en.Retrieve();

                    WorkNode wn = new WorkNode(en, nd);
                    _HisStartWorkNode = wn;

                }
                return _HisStartWorkNode;
            }
        }
        #endregion

        #region  Operational Attributes 
        public int _IsComplete = -1;
        /// <summary>
        ///  Is not complete 
        /// </summary>
        public bool IsComplete
        {
            get
            {

                //  bool s = !DBAccess.IsExits("select workid from WF_GenerWorkFlow WHERE WorkID=" + this.WorkID + " AND FK_Flow='" + this.HisFlow.No + "'");

                GenerWorkFlow generWorkFlow = new GenerWorkFlow(this.WorkID);
                if (generWorkFlow.WFState == WFState.Complete)
                    return true;
                else
                    return false;

            }
        }
        /// <summary>
        ///  Is not complete 
        /// </summary>
        public string IsCompleteStr
        {
            get
            {
                if (this.IsComplete)
                    return "╥╤";
                else
                    return "╬┤";
            }
        }
        #endregion

        #region  Static methods 

        /// <summary>
        ///  The staff is able to perform the job 
        /// </summary>
        /// <param name="nodeId"> Node </param>
        /// <param name="empId"> Staff </param>
        /// <returns> Can not be executed </returns> 
        public static bool IsCanDoWorkCheckByEmpStation(int nodeId, string empId)
        {
            bool isCan = false;
            //  Determine the correspondence between positions is not able to perform .
            string sql = "SELECT a.FK_Node FROM WF_NodeStation a,  Port_EmpStation b WHERE (a.FK_Station=b.FK_Station) AND (a.FK_Node=" + nodeId + " AND b.FK_Emp='" + empId + "' )";
            isCan = DBAccess.IsExits(sql);
            if (isCan)
                return true;
            //  His main job judge can not execute it .
            sql = "select FK_Node from WF_NodeStation WHERE FK_Node=" + nodeId + " AND ( FK_Station in (select FK_Station from Port_Empstation WHERE FK_Emp='" + empId + "') ) ";
            return DBAccess.IsExits(sql);
        }
        /// <summary>
        ///  The staff is able to perform the job 
        /// </summary>
        /// <param name="nodeId"> Node </param>
        /// <param name="dutyNo"> Staff </param>
        /// <returns> Can not be executed </returns> 
        public static bool IsCanDoWorkCheckByEmpDuty(int nodeId, string dutyNo)
        {
            string sql = "SELECT a.FK_Node FROM WF_NodeDuty  a,  Port_EmpDuty b WHERE (a.FK_Duty=b.FK_Duty) AND (a.FK_Node=" + nodeId + " AND b.FK_Duty=" + dutyNo + ")";
            if (DBAccess.RunSQLReturnTable(sql).Rows.Count == 0)
                return false;
            else
                return true;
        }
        /// <summary>
        ///  The staff is able to perform the job 
        /// </summary>
        /// <param name="nodeId"> Node </param>
        /// <param name="DeptNo"> Staff </param>
        /// <returns> Can not be executed </returns> 
        public static bool IsCanDoWorkCheckByEmpDept(int nodeId, string DeptNo)
        {
            string sql = "SELECT a.FK_Node FROM WF_NodeDept  a,  Port_EmpDept b WHERE (a.FK_Dept=b.FK_Dept) AND (a.FK_Node=" + nodeId + " AND b.FK_Dept=" + DeptNo + ")";
            if (DBAccess.RunSQLReturnTable(sql).Rows.Count == 0)
                return false;
            else
                return true;
        }

        /// <summary>
        ///  Who are physically able to do the job structure .
        /// </summary>
        /// <param name="nodeId"> Node ID</param>		 
        /// <returns></returns>
        public static DataTable CanDoWorkEmps(int nodeId)
        {
            string sql = "select a.FK_Node, b.EmpID from WF_NodeStation  a,  Port_EmpStation b WHERE (a.FK_Station=b.FK_Station) AND (a.FK_Node=" + nodeId + " )";
            return DBAccess.RunSQLReturnTable(sql);
        }
        /// <summary>
        /// GetEmpsBy
        /// </summary>
        /// <param name="dt"></param>
        /// <returns></returns>
        public Emps GetEmpsBy(DataTable dt)
        {
            //  Formation can handle this thing users geometry .
            Emps emps = new Emps();
            foreach (DataRow dr in dt.Rows)
            {
                emps.AddEntity(new Emp(dr["EmpID"].ToString()));
            }
            return emps;
        }

        #endregion

        #region  Process approach 

        private string _AppType = null;
        /// <summary>
        ///  Virtual directory path 
        /// </summary>
        public string AppType
        {
            get
            {
                if (_AppType == null)
                {
                    if (BP.Sys.SystemConfig.IsBSsystem == false)
                    {
                        _AppType = "WF";
                    }
                    else
                    {
                        if (BP.Web.WebUser.IsWap)
                            _AppType = "WF/WAP";
                        else
                        {
                            bool b = BP.Sys.Glo.Request.RawUrl.ToLower().Contains("oneflow");
                            if (b)
                                _AppType = "WF/OneFlow";
                            else
                                _AppType = "WF";
                        }
                    }
                }
                return _AppType;
            }
        }
        private string _VirPath = null;
        /// <summary>
        ///  Virtual directory path 
        /// </summary>
        public string VirPath
        {
            get
            {
                if (_VirPath == null)
                {
                    if (BP.Sys.SystemConfig.IsBSsystem)
                        _VirPath = BP.Sys.Glo.Request.ApplicationPath;
                    else
                        _VirPath = "";
                }
                return _VirPath;
            }
        }
        /// <summary>
        ///  Pending execution 
        /// </summary>
        /// <param name="way"> Suspend Mode </param>
        /// <param name="relData"> Release date </param>
        /// <param name="hungNote"> Pending reason </param>
        /// <returns></returns>
        public string DoHungUp(HungUpWay way, string relData, string hungNote)
        {
            if (this.HisGenerWorkFlow.WFState == WFState.HungUp)
                throw new Exception("@ The current state is already pending, you can not suspend execution .");

            if (string.IsNullOrEmpty(hungNote))
                hungNote = "╬▐";

            if (way == HungUpWay.SpecDataRel)
                if (relData.Length < 10)
                    throw new Exception("@ Pending the lifting date is incorrect (" + relData + ")");
            if (relData == null)
                relData = "";

            HungUp hu = new HungUp();
            hu.FK_Node = this.HisGenerWorkFlow.FK_Node;
            hu.WorkID = this.WorkID;
            hu.MyPK = hu.FK_Node + "_" + hu.WorkID;
            hu.HungUpWay = way; // Suspend Mode .
            hu.DTOfHungUp = DataType.CurrentDataTime; //  Hang time 
            hu.Rec = BP.Web.WebUser.No;  // Suspend people 
            hu.DTOfUnHungUp = relData; //  Lift hang time .
            hu.Note = hungNote;
            hu.Insert();

            /*  Get its workers , Send a message to them .*/
            GenerWorkerLists wls = new GenerWorkerLists(this.WorkID, this.HisFlow.No);
            string url = Glo.ServerIP + "/" + this.VirPath + this.AppType + "/WorkOpt/OneWork/Track.aspx?FK_Flow=" + this.HisFlow.No + "&WorkID=" + this.WorkID + "&FID=" + this.HisGenerWorkFlow.FID + "&FK_Node=" + this.HisGenerWorkFlow.FK_Node;
            string mailDoc = " Details :<A href='" + url + "'> Open process track </A>.";
            string title = " The work :" + this.HisGenerWorkFlow.Title + " ▒╗" + WebUser.Name + " Pending " + hungNote;
            string emps = "";
            foreach (GenerWorkerList wl in wls)
            {
                if (wl.IsEnable == false)
                    continue; // Not sent to the disabled person .

                //BP.WF.Port.WFEmp emp = new Port.WFEmp(wl.FK_Emp);
                emps += wl.FK_Emp + "," + wl.FK_EmpText + ";";

                // Write messages .
                BP.WF.Dev2Interface.Port_SendMsg(wl.FK_Emp, title, mailDoc, "HungUp" + wl.WorkID, BP.WF.SMSMsgType.Self, wl.FK_Flow, wl.FK_Node, wl.WorkID, wl.FID);
            }

            /*  Carried out  WF_GenerWorkFlow  Pending . */
            int hungSta = (int)WFState.HungUp;
            string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;
            Paras ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkFlow SET WFState=" + dbstr + "WFState WHERE WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkFlowAttr.WFState, hungSta);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Update process status report . 
            ps = new Paras();
            ps.SQL = "UPDATE " + this.HisFlow.PTable + " SET WFState=" + dbstr + "WFState WHERE OID=" + dbstr + "OID";
            ps.Add(GERptAttr.WFState, hungSta);
            ps.Add(GERptAttr.OID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Workers hang time update .
            ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkerlist SET DTOfHungUp=" + dbstr + "DTOfHungUp,DTOfUnHungUp=" + dbstr + "DTOfUnHungUp, HungUpTimes=HungUpTimes+1 WHERE FK_Node=" + dbstr + "FK_Node AND WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkerListAttr.DTOfHungUp, DataType.CurrentDataTime);
            ps.Add(GenerWorkerListAttr.DTOfUnHungUp, relData);

            ps.Add(GenerWorkerListAttr.FK_Node, this.HisGenerWorkFlow.FK_Node);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Logging ..
            WorkNode wn = new WorkNode(this.WorkID, this.HisGenerWorkFlow.FK_Node);
            wn.AddToTrack(ActionType.HungUp, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name, hungNote);
            return " Has been successfully executed pending , And has been notified to the :" + emps;
        }
        /// <summary>
        ///  Unsuspend 
        /// </summary>
        /// <returns></returns>
        public string DoUnHungUp()
        {
            if (this.HisGenerWorkFlow.WFState != WFState.HungUp)
                throw new Exception("@ Non-suspended state , You can not lift the hang .");

            /*  Pending implementation of the disarmament . */
            int sta = (int)WFState.Runing;
            string dbstr = BP.Sys.SystemConfig.AppCenterDBVarStr;
            Paras ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkFlow SET WFState=" + dbstr + "WFState WHERE WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkFlowAttr.WFState, sta);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Update process status report . 
            ps = new Paras();
            ps.SQL = "UPDATE " + this.HisFlow.PTable + " SET WFState=" + dbstr + "WFState WHERE OID=" + dbstr + "OID";
            ps.Add(GERptAttr.WFState, sta);
            ps.Add(GERptAttr.OID, this.WorkID);
            DBAccess.RunSQL(ps);

            //  Workers hang time update .
            ps = new Paras();
            ps.SQL = "UPDATE WF_GenerWorkerlist SET  DTOfUnHungUp=" + dbstr + "DTOfUnHungUp WHERE FK_Node=" + dbstr + "FK_Node AND WorkID=" + dbstr + "WorkID";
            ps.Add(GenerWorkerListAttr.DTOfUnHungUp, DataType.CurrentDataTime);
            ps.Add(GenerWorkerListAttr.FK_Node, this.HisGenerWorkFlow.FK_Node);
            ps.Add(GenerWorkFlowAttr.WorkID, this.WorkID);
            DBAccess.RunSQL(ps);

            // Update  HungUp
            HungUp hu = new HungUp();
            hu.FK_Node = this.HisGenerWorkFlow.FK_Node;
            hu.WorkID = this.HisGenerWorkFlow.WorkID;
            hu.MyPK = hu.FK_Node + "_" + hu.WorkID;
            if (hu.RetrieveFromDBSources() == 0)
                throw new Exception("@ System error , Did not find the point of suspension ");

            hu.DTOfUnHungUp = DataType.CurrentDataTime; //  Hang time 
            hu.Update();

            // His primary key update .
            ps = new Paras();
            ps.SQL = "UPDATE WF_HungUp SET MyPK=" + SystemConfig.AppCenterDBVarStr + "MyPK WHERE MyPK=" + dbstr + "MyPK1";
            ps.Add("MyPK", BP.DA.DBAccess.GenerGUID());
            ps.Add("MyPK1", hu.MyPK);
            DBAccess.RunSQL(ps);


            /*  Get its workers , Send a message to them .*/
            GenerWorkerLists wls = new GenerWorkerLists(this.WorkID, this.HisFlow.No);
            string url = Glo.ServerIP + "/" + this.VirPath + this.AppType + "/WorkOpt/OneWork/Track.aspx?FK_Flow=" + this.HisFlow.No + "&WorkID=" + this.WorkID + "&FID=" + this.HisGenerWorkFlow.FID + "&FK_Node=" + this.HisGenerWorkFlow.FK_Node;
            string mailDoc = " Details :<A href='" + url + "'> Open process track </A>.";
            string title = " The work :" + this.HisGenerWorkFlow.Title + " ▒╗" + WebUser.Name + " Lifted pending .";
            string emps = "";
            foreach (GenerWorkerList wl in wls)
            {
                if (wl.IsEnable == false)
                    continue; // Not sent to the disabled person .

                emps += wl.FK_Emp + "," + wl.FK_EmpText + ";";

                // Write messages .
                BP.WF.Dev2Interface.Port_SendMsg(wl.FK_Emp, title, mailDoc,
                    "HungUp" + wl.FK_Node + this.WorkID, BP.WF.SMSMsgType.Self, HisGenerWorkFlow.FK_Flow, HisGenerWorkFlow.FK_Node, this.WorkID, this.FID);

                // Write messages .
                //Glo.SendMsg(wl.FK_Emp, title, mailDoc);
            }


            //  Logging ..
            WorkNode wn = new WorkNode(this.WorkID, this.HisGenerWorkFlow.FK_Node);
            wn.AddToTrack(ActionType.UnHungUp, WebUser.No, WebUser.Name, wn.HisNode.NodeID, wn.HisNode.Name, " Lifted pending , Has been notified to the :" + emps);
            return null;
        }
        /// <summary>
        ///  Undo transfer 
        /// </summary>
        /// <returns></returns>
        public string DoUnShift()
        {
            GenerWorkFlow gwf = new GenerWorkFlow(this.WorkID);
            GenerWorkerLists wls = new GenerWorkerLists();
            wls.Retrieve(GenerWorkerListAttr.WorkID, this.WorkID, GenerWorkerListAttr.FK_Node, gwf.FK_Node);
            if (wls.Count == 0)
                return " No current job transfer failure .";

            Node nd = new Node(gwf.FK_Node);
            Work wk1 = nd.HisWork;
            wk1.OID = this.WorkID;
            wk1.Retrieve();

            //  Logging .
            WorkNode wn = new WorkNode(wk1, nd);
            wn.AddToTrack(ActionType.UnShift, WebUser.No, WebUser.Name, nd.NodeID, nd.Name, " Undo transfer ");

            if (wls.Count == 1)
            {
                GenerWorkerList wl = (GenerWorkerList)wls[0];
                wl.FK_Emp = WebUser.No;
                wl.FK_EmpText = WebUser.Name;
                wl.IsEnable = true;
                wl.IsPass = false;
                wl.Update();
                return "@ Undo transfer success ,<a href='" + Glo.CCFlowAppPath + "WF/MyFlow.aspx?FK_Flow=" + this.HisFlow.No + "&FK_Node=" + wl.FK_Node + "&FID=" + wl.FID + "&WorkID=" + this.WorkID + "'><img src='" + Glo.CCFlowAppPath + "WF/Img/Btn/Do.gif' border=0/> Implementation </A>";
            }

            bool isHaveMe = false;
            foreach (GenerWorkerList wl in wls)
            {
                if (wl.FK_Emp == WebUser.No)
                {
                    wl.FK_Emp = WebUser.No;
                    wl.FK_EmpText = WebUser.Name;
                    wl.IsEnable = true;
                    wl.IsPass = false;
                    wl.Update();
                    return "@ Undo transfer success ,<a href='" + Glo.CCFlowAppPath + "WF/MyFlow.aspx?FK_Flow=" + this.HisFlow.No + "&FK_Node=" + wl.FK_Node + "&FID=" + wl.FID + "&WorkID=" + this.WorkID + "'><img src='" + Glo.CCFlowAppPath + "WF/Img/Btn/Do.gif' border=0/> Implementation </A>";
                }
            }

            GenerWorkerList wk = (GenerWorkerList)wls[0];
            GenerWorkerList wkNew = new GenerWorkerList();
            wkNew.Copy(wk);
            wkNew.FK_Emp = WebUser.No;
            wkNew.FK_EmpText = WebUser.Name;
            wkNew.IsEnable = true;
            wkNew.IsPass = false;
            wkNew.Insert();

            return "@ Undo transfer success ,<a href='" + Glo.CCFlowAppPath + "WF/MyFlow.aspx?FK_Flow=" + this.HisFlow.No + "&FK_Node=" + wk.FK_Node + "&FID=" + wk.FID + "&WorkID=" + this.WorkID + "'><img src='" + Glo.CCFlowAppPath + "WF/Img/Btn/Do.gif' border=0/> Implementation </A>";
        }
        #endregion
    }
    /// <summary>
    ///  Workflow collection .
    /// </summary>
    public class WorkFlows : CollectionBase
    {
        #region  Structure 
        /// <summary>
        ///  Workflow 
        /// </summary>
        /// <param name="flow"> Process ID </param>
        public WorkFlows(Flow flow)
        {
            StartWorks ens = (StartWorks)flow.HisStartNode.HisWorks;
            ens.RetrieveAll(10000);
            foreach (StartWork sw in ens)
            {
                this.Add(new WorkFlow(flow, sw.OID, sw.FID));
            }
        }
        /// <summary>
        ///  Workflow collection 
        /// </summary>
        public WorkFlows()
        {
        }
        /// <summary>
        ///  Workflow collection 
        /// </summary>
        /// <param name="flow"> Process </param>
        /// <param name="flowState"> The work ID</param> 
        public WorkFlows(Flow flow, int flowState)
        {
            //StartWorks ens = (StartWorks)flow.HisStartNode.HisWorks;
            //QueryObject qo = new QueryObject(ens);
            //qo.AddWhere(StartWorkAttr.WFState, flowState);
            //qo.DoQuery();
            //foreach (StartWork sw in ens)
            //{
            //    this.Add(new WorkFlow(flow, sw.OID, sw.FID));
            //}
        }

        #endregion

        #region  Query methods 
        /// <summary>
        /// GetNotCompleteNode
        /// </summary>
        /// <param name="flowNo"> Process ID </param>
        /// <returns>StartWorks</returns>
        public static StartWorks GetNotCompleteWork(string flowNo)
        {
            return null;

            //Flow flow = new Flow(flowNo);
            //StartWorks ens = (StartWorks)flow.HisStartNode.HisWorks;
            //QueryObject qo = new QueryObject(ens);
            //qo.AddWhere(StartWorkAttr.WFState, "!=", 1);
            //qo.DoQuery();
            //return ens;

            /*
            foreach(StartWork sw in ens)
            {
                ens.AddEntity( new WorkFlow( flow, sw.OID) ) ; 
            }
            */
        }
        #endregion

        #region  Method 
        /// <summary>
        ///  Adding a workflow 
        /// </summary>
        /// <param name="wn"> Workflow </param>
        public void Add(WorkFlow wn)
        {
            this.InnerList.Add(wn);
        }
        /// <summary>
        ///  Access to data based on location 
        /// </summary>
        public WorkFlow this[int index]
        {
            get
            {
                return (WorkFlow)this.InnerList[index];
            }
        }
        #endregion

        #region  About scheduling automatic method 
        /// <summary>
        ///  Clear dead node .
        ///  Produce dead nodes , It is illegal to operate user , Storage or system failure occurs , The current process does not work due to node staff , And thus can not continue normal operation .
        ///  Clear dead node , That is, put them inside a collection of dead nodes work .
        /// </summary>
        /// <returns></returns>
        public static string ClearBadWorkNode()
        {
            string infoMsg = " Clear information about the death of nodes :";
            string errMsg = " Clear dead node error message :";
            return infoMsg + errMsg;
        }
        #endregion
    }
}
